DBS: Database system
DBMS: Database Management system
        control mgmnt, retrieval of file system
        Defines Data, format, boundary, transaction support,
        Concurrency Control: many users can access Data
        Recovery Mechanism: recovery data if damaged or loss, features to recovery
        Security and Integrity: Information should reflect the same across all users, control access
                                to Database
        DBMS: Ability to export and import functions
            *Benefits: sharing of data across applications
        Data Independence: if changed, still works across applications
        Enforce intergrity constraints: enforce correct data type constraints
        Better transaction support: property transaction maintanence support
        Enforce Standards:
        Backup and recovery modes:


*************Three Schema Architecture************************

select * | columnnames, columnnames from tablename

**How to filter records
    select statement
    where clause


    -select first_name, last_name, salary
     from employees
     where salary > 10000

     =, != (char)

     multiple condition operator
        -logical operator
            *and or not
                select first_name, last_name, salary
                from employees
                where salary > 10000 and salary < 15000

                select first_name, last_name, salary
                from employees
                where not ( salary > 10000 and salary < 15000)

                select first_name, last_name, salary
                from employees
                where (department_id=50 or department_id=80) and salary > 8000

        **Special Operators
            -between, in, is, like
                

                *between: range value
                    select first_name, last_name, salary
                    from employees
                    where salary between 8000 and 11000

                *in: list value
                    select first_name, last_name, salary
                    from employees
                    where department_id in (20,10,80)
                
                *like: can be used for integer values as well as char
                    %:any char more than one char
                    _%:any second character should be

                    select first_name, last_name, salary
                    from employees
                    where first_name like 'S%'
                *is: display null or not null value
                    select first_name, commission_pct 
                    from employees
                    where commission_pct is null;

                    select first_name, commission_pct 
                    from employees
                    where commission_pct is not null;
                *order by 
                    -used to sort information, ascending or descending
                    -asc by default
                        select first_name, last_name, salary
                        from employees
                        order by salary desc;
                    *multiple column
                        select first_name,department_id, job_id, last_name, salary
                        from employees
                        order by department_id, job_id;
                *group by
                    display total salary for each department_id
                        select column from tablename
                        where clause
                        group by 
                        order by
                        -columnname should be group
                        -any column wihtout aggregate should be part of group by
                        -display salary for each department_id
                            select department_id, job_id,sum(salary)
                            from employees
                            where salary > 5000
                            group by department_id, job_id
                            order by department_id

                *having clause
                    -display salary greater than 50000
                    -where clause does not support aggregate function
                    -having clause is used to define the conditional statment aggregate function
                    select department_id, job_id,sum(salary)
                    from employees
                    where salary > 5000
                    having sum(salary) > 50000
                    group by department_id, job_id
                    order by department_id
                            
                *aggregate function avg,max, min,sum, count, count(*), distinct
                    select sum(salary), max(Salary), min(Salary),avg(Salary) from employees;
                    select distinct(department_id) from employees;
                    * count(*): will count only record with the value
                            select count(*) from employees;
                    * count: counts values that are not null
                            select count(commission_pct) from employees;

                *single row functions
                    *String functions(upper, length, lpad(),rpad(),)
                        select upper(first_name) length(first_name), lpad(first_name,3),rpad(first_name,10,'*'),
                    
                        from employees
                    *date functions
                        -dual is system
                        select sysdate from dual;
                        select first_name, hire_date, date_add(hire_date,10,day) 
                        from employees;
                        select first_name, hire_date,next_day(hire_date,'Tuesday'),last_Day(hire_date)
                        from employees;
                        select first_name,hire_date,add_months(hire_date,10)
                        from employees;
                        select first_name,hire_date,add_months(hire_date,10),extract(year from hire_date)
                        from employees;

                        -format specific date
                        -DW: specific week of year
                        -W: week of MONTH
                        -YYYY: full year

                        select first_name,hire_date, to_date(hire_date,'DD MONTH YYYY')
                        from employees;

                        -round
                        select round(10000.3456,2) from dual
                    *numeric functions

                **Joins**

                    inner join:
                        query data from two or more tables(inner joined area in venn diagram)

                        list customerid book id book title and qty of all books sold 
                        select books.book_id, Books.book_title, book_sales.cust_id, book_sales.qty
                        FROM Books INNER JOIN Book_Sales
                        ON Books.Book_id = Book_Sales.book_id
                        Where Book_Type='DB'

                    **Cartesian Joining
                        -Default join method if inner is not specified
                        -each row is paired with all the rows in the second table
                        -happens when relationship is not defined between two table or there is  no common column between them
                    -used to join multiple tables
                        *cross join: joining first and second
                            select * from employees cross join departments
                        *innter join: finding out the common column between two tables, also the value should match
                            select first_name, department_name from employees join departments 
                            on employees.department_id = departments.department_id 
                            join locations on departments.location_id
                             where departments.department_id = locations.location_id
                            where salary > 8000
                            order by department_name
                            **WRong
                        *outer join: Joining two tables will display contents of all joins on left, right, full
                            -left, right, full(combination of left and right table)
                            select first_name, department_name
                            from employees 
                            right join departments
                            on employees.department_id = departments.department_id
                        *self join: joining within the same table, on is better than where
                            select e.first_name,m.first_name from employees e
                            join employees m
                            on e.manager_id = m.employee_id
                **Sub-Queries
                    query within query
                    outer query and inner
                        *select first_name, department_id, salary from employees
                        where department_id in 
                        (select department_id from departments
                        where department_name ='IT' or department_name = 'Marketing')
                        and salary > 7500
                        order by first_name desc
                    outer
                    select first_name 
                    from employees
                    where salary =(select max(salary) from employees)
            *Any and all.  Any= minimum, All=maximum

                /*****/Look up ANY vs ALL/*************/
                
                select first_name, salary
                from employees
                where salary > any(select salary from employees
                where department_id = 60 or department_id = 80) 
                >any means(it should be greather than any value in the list)
        *Set operators
            Union: display unique value from multiple columns
            Union All: display duplicates
            Intersect: display common values in both tables
                select department_id from employees
                Intersect
                select department_id from departments
            Minus: difference between two table value.. a minus b = a - (a and b)
                select department_id from employees
                Union All
                select department_id from departments
    DDL: Data Definition Language
                Create, Alter, Drop, Trunacate
                Synatx:
                    create table tablename(
                        columnname datatype null/notnull,
                        columnname datatype null/notnull
                    );
                    by default it is null, you can ignore value of column
                    number whole or decimal
                    date-
                    char- fixed size
                    varchar2-will locate memory based on size
                Example:
                create table student(
                    id number(5) not null,
                    name varchar2(50) not null,
                    gender  char(1) not null,
                    city varchar2(50),
                    dob date not null,
                    fees number(10,2)          
                )
                create table course(
                    id number(5) constraint c_pk_course_id primary key,
                    name varchar2(50)
                );
    DML: Insert, delete and update
        Insert:
            insert into student values(1,'ravi','m','chn','12-jan-10',100000.50);
            **if using null values, use column names
            insert  into student(id, name, gender, dob) values(blah, blah, blah)
            **insert directly (prompts user to enter values)
            insert into student value(&id,'&name', '&gener', '&city', '&dob', &fees)
        Update: 
            Synatx:
                update tablename
                set column = value
                where condition

                update student
                set city = 'kn', fees = 25000.00
                where name = 'mahesh'


                UPDATE Book_Customer c set cust_category = 'H'
                WHERE EXISTS(
                    SELECT 1 FROM Book_Sales s, Books b
                    WHERE s.book_id = b.book_id
                    AND s.cust_id = c.cust_id
                    GROUP BY cust_id
                    HAVING SUM(qty * book_cost) > 10000
                )
        delete:
                delete from tablename
               
                where
                ///or to delete entire record
                delete tablename;
        alter:
                syntax:
                    //modify column name
                    alter table tablename
                    modify city varchar2(100)

                    //add new column
                    alter table tablename
                    add newColumnName datatype

                    //remove column
                    alter table tablename
                    drop column columnname

                    //rename column
                    alter table tablename
                    rename column dob to date_of_birth

                    //rename table
                    alter table tablename 
                    rename to newTableName

                    //add constraint existing tablea
                    alter table emp1
                    add constraint c_pk_emp1 primary key(id)
    constraints:
    select constrain_name, constraint
        Primary key:
            does not take duplicat value or null.
        Foreign key:
            refers to primary key table, becomes the child table, primary becomes 
            parent table 

               
        Check:
            create table emp(
                id number(5) not null,
                name varchar2(50),
                salary number(10,2) check (salary > 0)
            ) 

            insert into emp values(1,'a',1000)
        Default:
            if you do not put any value to the column, it will put default value

                create table emp1(
                    id number(10),
                    name varchar2(50),
                    city varchar2(50) default 'New York'
                )
        Unique:
            Does not take any duplicate value. Can  have null value.
                create table course1(
                    id number(5) constraint c_uq_course1_id unique,
                    name varchar2(50)

                )
    Views:
        a mirror of a table, view does not exist physically
        view can be created by a query joining one or more tables
        view does not store data
        good for presenting data to userGood for fetching info instead of directly accessing from table
        view will become read only (cannot perform insert, delete, but can update in a few seconds)
            create or replace view view1
            as
            select first_name, department_name from employees
            join departments on employees.employee_id = departments.department_id
            
    Indexes:
            select * from all_indexes;
             indexes are used to increase performance of tables
            primary key creation creates index automatically
            can be used to increase performance and fetch effeciently
            non key 

            create index index1 on emp1(name);
            
    Sequences:
            nextval is used to capture the next value
            sequence is used to generate the number automatically
                create sequence s1
                start with 100
                increment by 1
                maxvalue 1000;
    Pl/SQL:

    Transaction mgmt:  Ensuring atomicity/cardinality.
        A transaction is single unit of work composed of one, two or more tasks - Logic Unit of work.
        Update Journal Entry

        State diagram transaction begin->ACTIVE->PARTIALLY COMPLETED->COMMITED->FAILED->ABORTED


        Transaction processing system:  
            Batch Processing: automated processes, end of quarter/month etc.
            Real Time: ATM, Billing, etc
            On-line: 

        Atomicity: no half transactions. if complete, commited.  if failed, rollback.
        Consistency: ensure db is in consistent state. uniqueness, referential integrity
        Isolation: enable concurrent execution of transaction while ensuring that obtained by sequential execution.  Multiple executions should not 
                   impact others execution.  Need for concurrency, multiple access ability for given time.
        Durability:after successful transaction, all updates are permanent irrespective of system failure.

                    
    //***************************************************//
    /****************Day Three*****************************/
    /******************************************************/          

    Procedural Language Structured Query Language
        *Procedural Language: Combination of SQL along with procedural programming
        *Portable high performance provides a built in and also independent programming environment
        *Any pl/sql statement will be stored in the database
        *Allows functions, data types, DML
        *Reduces network traffic
        *Handle Exceptions
        *Packages

        -***Variable Declaration
            @Begin
                declare
                execute commands
                exception handling
                    statement
            declare
                Declaration
            Begin
                commands
            Exceptions
                statement
            End;

            Declare
	        -- this is a comment line
	            name varchar2(50) := '&name';
            Begin
	            dbms_output.put_line('my name is ' || name);
            end;
            

            Declare
            	num1 int := &num1;
	            num2 int := &num2;
	            result int := 0;
            Begin
                result := num1 + num2;
                dbms_output.put_line('sum: '|| result);
            end;


            declare
                pi constant number := 3.142;
                radius number := &radius;
                area number(10,2);
            begin
                area := radius * radius * pi;
                dbms_output.put_line(area);
            end;
            /
    ***************************************************************************
    ******************Branch Statements/Loops****************************************
    declare
        num1 number(10) := &num1;
    begin
        if(num1 > 20) then
        dbms_output.put_line('greater');
        else
        dbms_output.put_line('less');
        end if;
    end;

    declare
  grade char := '&grade';
    begin
        case grade
        when 'A' then
            dbms_output.put_line('excellent');
        when 'B' then
            dbms_output.put_line('very good');
        else
            dbms_output.put_line('failed');
        end case;
    end;
    /

    declare
    a number := 10;
    Begin
    while a >= 1
        loop
        dbms_output.put_line(a);
        a := a - 1;
    end loop;
    end;


    declare
        x number := 1;
    begin
        loop 
            dbms_output.put_line(x);
            x := x + 1;
            if x < 3 then
                continue;
            end if;
            dbms_output.put_line(x || 'after continue');
            exit when x = 5;
        end loop;
    end;
    /
/////////////////////*****************************************//////////
******************Names******************************
declare
    type namearray is varray(5) of varchar2(50);
    names namearray;
begin
    names := namearray('ram','ravi','satish','subhash','mahesh');
    dbms_output.put_line(names.count);
    for i in 1..names.count
    loop
        dbms_output.put_line(names(i));
    end loop;
end;
/
procedures:
    sub programming: contains block of statement
        -something which can hold a set of statements that can perform a particular
            task, where stored procedures can take parameters,
            *can not return any value                            
                -in: take input from user 
                -out: output value to user
                -inout: take input output value
            *creat or replace procedure name
            as 
            begin 
                statement
            end;

            Example:
            create or replace procedure p2
            (num1 in number, num2 in number, num3 out number)
            is
            begin
                num3 := num1 + num2;
                dbms_output.put_line(result);
            end;
            /

            ///Now call procedure
            declare
            result number;
            begin
                 p2(20,20,result);
                 dbms_output.put_line(result);
            end;
            /

            create table student8(
	id number(10),
	name varchar(50)
)

        create or replace procedure p3(
            id in number, name in varchar2
        )
        is begin 
        insert into student8 values(id, name);
        end;
        /

        begin 
        p3(2,'b');
        p3(1,'a');
        end;/
    //functions



    //*********************************************************************//
    *****************EXPLICIT CURSORS**************************************
      Syntax:
    Declare
        CURSOR emp_cur IS 
        SELECT emp_id, emp_name, department_name
        FROM emp e, dept damaged
        WHERE d.dept_no = 10
        AND e.dept_no = d.dept_no;
    BEGIN
    Example:

///////////////////////////////////////////////////////////////////////////////
@@@@@@@@@@@@@@@@@@@ Cursor@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
CREATE OR REPLACE PROCEDURE P5(eid in number)
IS
    fname varchar2(100);
    salary number(10,2);
BEGIN
    SELECT first_name, salary 
    into fname, salary 
    FROM employees
    WHERE employee_id = eid;
    dbms_output.put_line(fname || ' ' || salary);
END;
/


        -Cursor: used to get information from an SQL statement
            * When you have more than one record
                -implicit : automatically generated by sql
                -explicit : manually generate SQL

                %ROWTYPE : IT WILL get the type of select statement
                %ROWCOUNT : number of rows
                %FOUND : whether the record exists or not
                %NOTFOUND : whether the record does not exist
                %ISOPEN  : if cursor is open


        *IMPLICIT CURSOR EXAMPLE:
        DECLARE
            total number(10);

        BEGIN
            UPDATE emp1
            set city = 'New York';
            IF SQL%NOTFOUND THEN
                dbms_output.put_line('no records updated');
            ELSE
                total := SQL%ROWCOUNT;
                dbms_output.put_line('no of records updated:' || total );
            END IF;
        END;
        /       

        ***EXplicit cursor
            cursor nameofcursor is select statement
            wee need to open cursor
            fetch data from cursor
            then close cursor      
                DECLARE
                    fname employees.first_name%TYPE;
                    sal employees.salary%TYPE;
                    deptid employees.department_id%TYPE := &deptid;
                    CURSOR c_id is 
                        SELECT first_name, salary 
                        FROM employees
                        WHERE department_id = DEPTID;

                BEGIN
                    OPEN c_id;
                    LOOP 
                        FETCH c_id 
                        INTO fname, sal;
                        EXIT WHEN c_id%NOTFOUND;
                        dbms_output.put_line(fname || ' ' || sal);
                        end loop;
                        close c_id;
                
                END;
                /    

        **nother Example
        DECLARE
            dname departments.department_name%TYPE;
            --fname employees.first_name%TYPE;
            sal employees.salary%TYPE;
            deptid employees.department_id%TYPE;
            CURSOR c_id is 
                SELECT department_name, sum(salary) 
                FROM employees
                join departments on employees.department_id = departments.department_id
        

        BEGIN
            OPEN c_id;
            LOOP 
                FETCH c_id 
                INTO dname, sal;
                EXIT WHEN c_id%NOTFOUND;
                dbms_output.put_line(dname|| ' ' || sal);
                end loop;
                close c_id;
        
        END;
        /      

    **Exception handling    
        -invalid cursor
        -login denied 
        System Define:
            Exception thrown by system
        User Defined:
            Create our own exception

                DECLARE
                    fname           employees.first_name%TYPE;
                    sal             employees.salary%TYPE;
                    eid             employees.employee_id%TYPE := &eid;
                BEGIN
                    SELECT first_name, salary 
                    INTO fname, sal
                    FROM employees
                    WHERE employee_id = eid;
                    dbms_output.put_line( fname || ' ' || sal);
                    
                    -- EXCEPTION
                    EXCEPTION
                        WHEN NO_DATA_FOUND THEN
                            dbms_output.put_line('no such record exists');
                        WHEN OTHERS THEN    
                            dbms_output.put_line('Error!');

                    
                END;
                /


                DECLARE
                    fname           employees.first_name%TYPE;
                    sal             employees.salary%TYPE;
                    eid             employees.employee_id%TYPE := &eid;
                    invalid_eid     EXCEPTION;  --USER DEFINED EXCEPTION
                BEGIN
                    IF  eid <= 0   THEN
                        RAISE invalid_eid;
                    ELSE
                        SELECT first_name, salary 
                        INTO fname, sal
                        FROM employees
                        WHERE employee_id = eid;
                        dbms_output.put_line( fname || ' ' || sal);
                    END IF;

                    EXCEPTION
                    WHEN invalid_eid THEN
                            dbms_output.put_line('LESS THAN 0!');
                        WHEN NO_DATA_FOUND THEN
                            dbms_output.put_line('no such record exists');      -- IF NOT FOUND
                    
                        WHEN OTHERS THEN    
                            dbms_output.put_line('Error!');                 -- UNFORESEEN HANDLING1
                END;
                /

        **TRIGGERS
            -something used to perform on a table
                -insert, delete, UPDATE
                -USED ON DML STATEMENTS 

                

                CREATE OR REPLACE TRIGGER triggername
                    before | after
                    insert/update/delete
                    on which tablename
                    for each row
                        BEGIN
                        END;
                
                :new - insert
                :old -delete
                update - :new, :old

            EXample:
                CREATE OR REPLACE TRIGGER trig_insert
                after insert
                on emp1
                for each row
                    begin
                        insert into emp1 values(:new.id);
                        dbms_output.put('record inserted');
                end;
                /


            Create or replace trigger t_update
after update
for each row
	on emp4
	Begin
		update emp4
		set id = :new.id
		where id = :old.id
	End;
//


*********Packages

create or replace package pack_1
as 
    procedure g(eid in employees.employee_id%TYPE)
    is
        sal employees.salary%TYPE;

    begin
        select salary into sal from employees
        where employee_id = eid;
        dbms_output.put_line(salary);
    end g;

    procedure s(num1 in number)
    is 
    begin 
        dbms_output.put_line(num1);
    end s;
    end pack_1; 
/

                                

create package pack_4 as
procedure g( eid employee.employee_id%type);
procedure s(num1 in number);
end pack_4;
create or replace package pack_4
as 
    procedure g(eid in employees.employee_id%TYPE)
    as
        sal employees.salary%TYPE;
    begin
        select salary into sal from employees
        where employee_id = eid;
        dbms_output.put_line(sal);
    end g;
    procedure s(num1 in number)
    is 
    begin 
        dbms_output.put_line(num1);
    end s;
    end pack_4; 
/
/ 
